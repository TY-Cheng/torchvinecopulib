<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 7.3.5 and Furo 2024.01.29 -->
        <title>torchvinecopulib.vinecop._data_vcp - torchvinecopulib 2024.4.0rc1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?v=135e06be" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?v=36a5483c" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">torchvinecopulib 2024.4.0rc1 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">torchvinecopulib 2024.4.0rc1 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../torchvinecopulib.vinecop.html">torchvinecopulib.vinecop package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../torchvinecopulib.bicop.html">torchvinecopulib.bicop package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../torchvinecopulib.util.html">torchvinecopulib.util package</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <h1>Source code for torchvinecopulib.vinecop._data_vcp</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="kn">import</span> <span class="n">pformat</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>


<div class="viewcode-block" id="DataVineCop">
<a class="viewcode-back" href="../../../torchvinecopulib.vinecop.html#torchvinecopulib.vinecop.DataVineCop">[docs]</a>
<span class="nd">@dataclass</span><span class="p">(</span><span class="n">slots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kw_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">DataVineCop</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dataclass for a vine copula model&quot;&quot;&quot;</span>

    <span class="n">dct_bcp</span><span class="p">:</span> <span class="nb">dict</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;bivariate copulas, stored as {level: {(vertex_left, vertex_right, frozenset_cond): DataBiCop}}&quot;&quot;&quot;</span>
    <span class="n">dct_tree</span><span class="p">:</span> <span class="nb">dict</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;bivariate dependency measures of edges in trees, stored as {level: {(vertex_left, vertex_right, frozenset_cond): bidep}}&quot;&quot;&quot;</span>
    <span class="n">tpl_sim</span><span class="p">:</span> <span class="nb">tuple</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;the source vertices (pseudo-obs) of simulation paths, read from right to left; some vertices can be given as simulated at the beginning of each simulation workflow&quot;&quot;&quot;</span>
    <span class="n">mtd_bidep</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;method to calculate bivariate dependence&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param self: an instance of the DataVineCop dataclass</span>
<span class="sd">        :return: Akaike information criterion (AIC)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_par</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">negloglik</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param self: an instance of the DataVineCop dataclass</span>
<span class="sd">        :return: Bayesian information criterion (BIC)</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">negloglik</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_par</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_obs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;structure matrix: upper triangular, in row-major order (each row has a bicop as: vertex_left,...,vertex_right;set_cond)</span>

<span class="sd">        :return: structure matrix</span>
<span class="sd">        :rtype: np.array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># NumPy arrays, like arrays in C, are stored in row-major order by default.</span>
        <span class="c1"># In a 2D array, the data is stored row by row: elements in the same row are stored in adjacent memory locations.</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lst_diag</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># * levels in reverse order</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">lv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)):</span>
            <span class="n">v_diag</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">lst_nebr</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">i_lv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">[</span><span class="n">i_lv</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">v_l</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lst_diag</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v_r</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lst_diag</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">v_diag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="c1"># ! pick the node with smaller index (v_l &lt; v_r), then mat &lt;-&gt; structure is bijection</span>
                            <span class="n">v_diag</span> <span class="o">=</span> <span class="n">v_l</span>
                            <span class="n">lst_nebr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_diag</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">v_diag</span> <span class="ow">in</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">):</span>
                            <span class="n">lst_nebr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_l</span> <span class="k">if</span> <span class="n">v_diag</span> <span class="o">==</span> <span class="n">v_r</span> <span class="k">else</span> <span class="n">v_r</span><span class="p">)</span>
            <span class="n">lst_diag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_diag</span><span class="p">)</span>
            <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lst_nebr</span><span class="p">)</span>
        <span class="c1"># ! append the last node</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[</span><span class="n">mat</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">negloglik</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;nll, as sum of negative log likelihoods of all bivariate copulas</span>

<span class="sd">        :return: negative log likelihood</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">bcp</span><span class="o">.</span><span class="n">negloglik</span> <span class="k">for</span> <span class="n">dct_lv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_bcp</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">bcp</span> <span class="ow">in</span> <span class="n">dct_lv</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;number of dimensions&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;number of observations&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">bcp</span><span class="o">.</span><span class="n">num_obs</span> <span class="k">for</span> <span class="n">bcp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_bcp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_par</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;number of parameters&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">bcp</span><span class="o">.</span><span class="n">num_par</span> <span class="k">for</span> <span class="n">dct_lv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_bcp</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">bcp</span> <span class="ow">in</span> <span class="n">dct_lv</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>

    <span class="k">def</span> <span class="nf">_loc_bcp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v_down</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">s_down</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;locate the bicop on upper level that generates this pseudo obs</span>

<span class="sd">        :param v_down: given vertex on lower level</span>
<span class="sd">        :type v_down: int</span>
<span class="sd">        :param s_down: given cond set on lower level</span>
<span class="sd">        :type s_down: frozenset</span>
<span class="sd">        :return: vertex left, vertex right, cond set, and the bicop</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lv_up</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_down</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span> <span class="n">bcp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_bcp</span><span class="p">[</span><span class="n">lv_up</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="p">({</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">}</span> <span class="o">|</span> <span class="n">s_up</span><span class="p">)</span> <span class="o">==</span> <span class="p">({</span><span class="n">v_down</span><span class="p">}</span> <span class="o">|</span> <span class="n">s_down</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_up</span><span class="p">,</span> <span class="n">bcp</span>

    <span class="k">def</span> <span class="nf">_ref_count</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tpl_first_vs</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
        <span class="n">tpl_sim</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;reference counting for each vertex during simulation (quant-reg/cond-sim) workflow, for garbage collection (memory release)</span>

<span class="sd">        :param tpl_first_vs: tuple of vertices (explicitly arranged in conditioned - conditioning set) that are taken as known at the beginning of a simulation workflow, defaults to tuple()</span>
<span class="sd">        :type tpl_first_vs: tuple[tuple[int, frozenset]], optional</span>
<span class="sd">        :param tpl_sim: tuple of vertices in a full simulation workflow, gives flexibility to experienced users, defaults to tuple()</span>
<span class="sd">        :type tpl_sim: tuple[int], optional</span>
<span class="sd">        :return: reference counting for each vertex; list of source vertices in this simulation workflow from shallow to deep</span>
<span class="sd">        :rtype: tuple[dict, list[int]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># * v for vertex, s for condition (frozen)set, read from right to left</span>
        <span class="n">dct_first_vs</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tpl_first_vs</span><span class="p">}</span>
        <span class="n">lst_source</span> <span class="o">=</span> <span class="n">tpl_sim</span> <span class="k">if</span> <span class="n">tpl_sim</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_sim</span>
        <span class="n">lst_source</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">dct_first_vs</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dct_first_vs</span> <span class="k">else</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">lst_source</span><span class="p">[(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:])))</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst_source</span><span class="p">)</span>
        <span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># ! count in initial sim (pseudo obs that are given at the beginning of each sim path)</span>
        <span class="n">dct_ref_count</span> <span class="o">=</span> <span class="p">{</span><span class="n">v_s_cond</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">v_s_cond</span> <span class="ow">in</span> <span class="n">lst_source</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">visit_hfunc</span><span class="p">(</span><span class="n">v_down</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">s_down</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">):</span>
            <span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_up</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc_bcp</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_down</span><span class="p">)</span>
            <span class="c1"># vertex left on upper level</span>
            <span class="k">if</span> <span class="n">dct_ref_count</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">visit_hfunc</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_up</span><span class="p">)</span>
            <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_up</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># vertex right on upper level</span>
            <span class="k">if</span> <span class="n">dct_ref_count</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">visit_hfunc</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_up</span><span class="p">)</span>
            <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_up</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># * vertex reached by hfunc, on lower level</span>
            <span class="k">if</span> <span class="n">dct_ref_count</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">def</span> <span class="nf">visit_hinv</span><span class="p">(</span><span class="n">v_down</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">s_down</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">):</span>
            <span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_up</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc_bcp</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_down</span><span class="p">)</span>
            <span class="n">v_up</span> <span class="o">=</span> <span class="n">v_r</span> <span class="k">if</span> <span class="p">(</span><span class="n">v_down</span> <span class="o">==</span> <span class="n">v_l</span><span class="p">)</span> <span class="k">else</span> <span class="n">v_l</span>
            <span class="c1"># hfunc from even upper, to generate this vertex on upper level</span>
            <span class="k">if</span> <span class="n">dct_ref_count</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">v_up</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">visit_hfunc</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v_up</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_up</span><span class="p">)</span>
            <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v_up</span><span class="p">,</span> <span class="n">s_up</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># vertex on lower level</span>
            <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># * vertex reached by hinv</span>
            <span class="k">if</span> <span class="n">dct_ref_count</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_up</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_up</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">v_down</span><span class="p">,</span> <span class="n">s_up</span>

        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lst_source</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v_next</span><span class="p">,</span> <span class="n">s_next</span> <span class="o">=</span> <span class="n">visit_hinv</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_next</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">v_next</span><span class="p">,</span> <span class="n">s_next</span> <span class="o">=</span> <span class="n">visit_hinv</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v_next</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_next</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dct_ref_count</span><span class="p">,</span> <span class="n">lst_source</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pformat</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="s2">&quot;dct_bcp&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_bcp</span><span class="p">,</span>
                <span class="s2">&quot;dct_tree&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">,</span>
                <span class="s2">&quot;tpl_sim&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_sim</span><span class="p">,</span>
                <span class="s2">&quot;mtd_bidep&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mtd_bidep</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">sort_dicts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">underscore_numbers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pformat</span><span class="p">(</span>
            <span class="nb">object</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;mtd_bidep&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mtd_bidep</span><span class="p">,</span>
                <span class="s2">&quot;num_dim&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">,</span>
                <span class="s2">&quot;num_obs&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_obs</span><span class="p">,</span>
                <span class="s2">&quot;num_par&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_par</span><span class="p">,</span>
                <span class="s2">&quot;negloglik&quot;</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">negloglik</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                <span class="s2">&quot;aic&quot;</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">aic</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                <span class="s2">&quot;bic&quot;</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bic</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                <span class="s2">&quot;matrix&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="fm">__str__</span><span class="p">(),</span>
                <span class="s2">&quot;tpl_sim&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_sim</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">compact</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">sort_dicts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">underscore_numbers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="DataVineCop.draw_lv">
<a class="viewcode-back" href="../../../torchvinecopulib.vinecop.html#torchvinecopulib.vinecop.DataVineCop.draw_lv">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_lv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lv</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">is_bcp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">num_digit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">font_size_vertex</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">font_size_edge</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
        <span class="n">f_path</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fig_size</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;draw the vine structure at a given level. Each edge corresponds to a fitted bicop. Each node is a bicop of prev lv (is_bcp=True) or pseudo-obs of the given lv (is_bcp=False).</span>

<span class="sd">        :param lv: level, defaults to 0</span>
<span class="sd">        :type lv: int, optional</span>
<span class="sd">        :param is_bcp: draw the minimum spanning tree (of prev lv bicops) or pseudo observations, defaults to True</span>
<span class="sd">        :type is_bcp: bool, optional</span>
<span class="sd">        :param num_digit: number of digits to round for the weights on edges, defaults to 2</span>
<span class="sd">        :type num_digit: int, optional</span>
<span class="sd">        :param font_size_vertex: font size for vertex labels, defaults to 8</span>
<span class="sd">        :type font_size_vertex: int, optional</span>
<span class="sd">        :param font_size_edge: font size for edge labels, defaults to 7</span>
<span class="sd">        :type font_size_edge: int, optional</span>
<span class="sd">        :param f_path: file path to save the figure, defaults to None for no saving</span>
<span class="sd">        :type f_path: Path, optional</span>
<span class="sd">        :param fig_size: figure size, defaults to None</span>
<span class="sd">        :type fig_size: tuple, optional</span>
<span class="sd">        :return: fig, ax, (and file path if the figure is saved)</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
            <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Vine Copula, Level </span><span class="si">{</span><span class="n">lv</span><span class="si">}</span><span class="s2">, BiDep Metric </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mtd_bidep</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="n">font_size_vertex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tpl_uvw</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">ndigits</span><span class="o">=</span><span class="n">num_digit</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_bcp</span><span class="p">:</span>
            <span class="n">tpl_uvw</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_loc_bcp</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">u</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_cond</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_loc_bcp</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_cond</span><span class="p">),</span>
                    <span class="nb">round</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">ndigits</span><span class="o">=</span><span class="n">num_digit</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">tpl_uvw</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tpl_l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">tpl_l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">;&quot;</span>
                    <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">sorted</span><span class="p">(</span><span class="n">tpl_l</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tpl_r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">tpl_r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">;&quot;</span>
                    <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">sorted</span><span class="p">(</span><span class="n">tpl_r</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">w</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">tpl_l</span><span class="p">,</span> <span class="n">tpl_r</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tpl_uvw</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tpl_uvw</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s_cond</span><span class="p">)])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">sorted</span><span class="p">(</span><span class="n">s_cond</span><span class="p">)])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="nb">round</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">ndigits</span><span class="o">=</span><span class="n">num_digit</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="n">tpl_uvw</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">planar_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span>
            <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
            <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;s&quot;</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_bcp</span> <span class="ow">and</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
            <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span><span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="n">font_size_vertex</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span>
            <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">edgelist</span><span class="o">=</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(),</span>
            <span class="n">width</span><span class="o">=</span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">+</span> <span class="mi">100</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tpl</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s2">&quot;weight&quot;</span><span class="p">]))</span> <span class="k">for</span> <span class="n">tpl</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)],</span>
            <span class="n">style</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span>
            <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">edge_labels</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s2">&quot;weight&quot;</span><span class="p">),</span>
            <span class="n">font_size</span><span class="o">=</span><span class="n">font_size_edge</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">draw_if_interactive</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">f_path</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="n">f_path</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">f_path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">G</span></div>


<div class="viewcode-block" id="DataVineCop.draw_dag">
<a class="viewcode-back" href="../../../torchvinecopulib.vinecop.html#torchvinecopulib.vinecop.DataVineCop.draw_dag">[docs]</a>
    <span class="k">def</span> <span class="nf">draw_dag</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tpl_first_vs</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
        <span class="n">tpl_sim</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
        <span class="n">font_size_vertex</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="n">f_path</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fig_size</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;draw the directed acyclic graph (DAG) of the vine copula, with pseudo observations and bicops as nodes. The source nodes in simulation workflow are highlighted in yellow.</span>

<span class="sd">        :param tpl_first_vs: tuple of vertices (explicitly arranged in conditioned - conditioning set) that are taken as already simulated at the beginning of a simulation workflow, affecting the color of nodes, defaults to tuple()</span>
<span class="sd">        :type tpl_first_vs: tuple, optional</span>
<span class="sd">        :param tpl_sim: tuple of vertices in a full simulation workflow, gives flexibility to experienced users, defaults to tuple()</span>
<span class="sd">        :type tpl_sim: tuple, optional</span>
<span class="sd">        :param font_size_vertex: font size for vertex labels, defaults to 8</span>
<span class="sd">        :type font_size_vertex: int, optional</span>
<span class="sd">        :param f_path: file path to save the figure, defaults to None for no saving</span>
<span class="sd">        :type f_path: Path, optional</span>
<span class="sd">        :param fig_size: figure size, defaults to None</span>
<span class="sd">        :type fig_size: tuple, optional</span>
<span class="sd">        :return: _description_</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="n">fig_size</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Vine Copula, Obs and BiCop&quot;</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="n">font_size_vertex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
        <span class="n">pos_obs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">pos_bcp</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dct_label</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">lv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">:</span>
            <span class="c1"># given a bcp, locate upper/lower edges and lower nodes</span>
            <span class="n">lst_node_bcp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lst_node_down</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lst_edge</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">lv</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># locate upper nodes only when lv==0</span>
                <span class="n">lst_node_up</span> <span class="o">=</span> <span class="p">[(</span><span class="n">_</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">lst_node_up</span><span class="p">:</span>
                    <span class="n">dct_label</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">num_node</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst_node_up</span><span class="p">)</span>
                <span class="n">loc_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">num_node</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_node</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num_node</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_node</span><span class="p">):</span>
                    <span class="n">pos_obs</span><span class="p">[</span><span class="n">lst_node_up</span><span class="p">[</span><span class="n">_</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loc_x</span><span class="p">[</span><span class="n">_</span><span class="p">],</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">),</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># node bcp</span>
                <span class="n">lst_node_bcp</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">))</span>
                <span class="c1"># node down</span>
                <span class="n">lst_node_down</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_cond</span> <span class="o">|</span> <span class="p">{</span><span class="n">v_r</span><span class="p">}))</span>
                <span class="n">lst_node_down</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span> <span class="o">|</span> <span class="p">{</span><span class="n">v_l</span><span class="p">}))</span>
                <span class="c1"># edge</span>
                <span class="n">lst_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">),</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">)))</span>
                <span class="n">lst_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">),</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">)))</span>
                <span class="n">lst_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">),</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_cond</span> <span class="o">|</span> <span class="p">{</span><span class="n">v_r</span><span class="p">})))</span>
                <span class="n">lst_edge</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">),</span> <span class="p">(</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span> <span class="o">|</span> <span class="p">{</span><span class="n">v_l</span><span class="p">})))</span>
            <span class="c1"># locate lower nodes</span>
            <span class="n">num_node</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst_node_down</span><span class="p">)</span>
            <span class="n">loc_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">num_node</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_node</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num_node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_node</span><span class="p">):</span>
                <span class="n">pos_obs</span><span class="p">[</span><span class="n">lst_node_down</span><span class="p">[</span><span class="n">_</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loc_x</span><span class="p">[</span><span class="n">_</span><span class="p">],</span> <span class="o">-</span><span class="n">lv</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">lst_node_down</span><span class="p">:</span>
                <span class="n">dct_label</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">__</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">__</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">sorted</span><span class="p">(</span><span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="c1"># locate bcp nodes</span>
            <span class="n">num_node</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst_node_bcp</span><span class="p">)</span>
            <span class="n">loc_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">num_node</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num_node</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num_node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_node</span><span class="p">):</span>
                <span class="n">pos_bcp</span><span class="p">[</span><span class="n">lst_node_bcp</span><span class="p">[</span><span class="n">_</span><span class="p">]]</span> <span class="o">=</span> <span class="n">loc_x</span><span class="p">[</span><span class="n">_</span><span class="p">],</span> <span class="o">-</span><span class="n">lv</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">lst_node_bcp</span><span class="p">:</span>
                <span class="n">__</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">lv</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">dct_label</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">;</span><span class="si">{</span><span class="n">__</span><span class="si">}{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">__</span><span class="si">}</span><span class="s1">&#39;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">__</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nb">sorted</span><span class="p">(</span><span class="n">_</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">lst_edge</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">pos_obs</span> <span class="o">|</span> <span class="n">pos_bcp</span>
        <span class="c1"># highlight source nodes, given tpl_first</span>
        <span class="n">lst_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_count</span><span class="p">(</span><span class="n">tpl_first_vs</span><span class="o">=</span><span class="n">tpl_first_vs</span><span class="p">,</span> <span class="n">tpl_sim</span><span class="o">=</span><span class="n">tpl_sim</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># pseudo obs nodes</span>
        <span class="n">lst_node</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lst_source</span><span class="p">]</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span>
            <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">nodelist</span><span class="o">=</span><span class="n">lst_node</span><span class="p">,</span>
            <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
            <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
            <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span>
            <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">nodelist</span><span class="o">=</span><span class="n">lst_source</span><span class="p">,</span>
            <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
            <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
            <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># bicop nodes</span>
        <span class="n">lst_node</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">]</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_nodes</span><span class="p">(</span>
            <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">nodelist</span><span class="o">=</span><span class="n">lst_node</span><span class="p">,</span>
            <span class="n">node_color</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
            <span class="n">node_shape</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
            <span class="n">linewidths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_labels</span><span class="p">(</span>
            <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">dct_label</span><span class="p">,</span>
            <span class="n">font_size</span><span class="o">=</span><span class="n">font_size_vertex</span><span class="p">,</span>
            <span class="n">font_color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span>
            <span class="n">G</span><span class="o">=</span><span class="n">G</span><span class="p">,</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">pos</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">edge_color</span><span class="o">=</span><span class="s2">&quot;gray&quot;</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">style</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">draw_if_interactive</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">f_path</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="o">=</span><span class="n">f_path</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s2">&quot;tight&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">f_path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">G</span></div>


<div class="viewcode-block" id="DataVineCop.vcp_to_json">
<a class="viewcode-back" href="../../../torchvinecopulib.vinecop.html#torchvinecopulib.vinecop.DataVineCop.vcp_to_json">[docs]</a>
    <span class="k">def</span> <span class="nf">vcp_to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_path</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="s2">&quot;./vcp.json&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;save to a json file</span>

<span class="sd">        :param self: an instance of the DataVineCop dataclass</span>
<span class="sd">        :param f_path: file path to save the json file, defaults to &#39;./vcp.json&#39;</span>
<span class="sd">        :type f_path: Path, optional</span>
<span class="sd">        :return: file path where the json file is saved</span>
<span class="sd">        :rtype: Path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">f_path</span><span class="p">)</span>
        <span class="n">f_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">f_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">f_path</span></div>


<div class="viewcode-block" id="DataVineCop.vcp_to_pkl">
<a class="viewcode-back" href="../../../torchvinecopulib.vinecop.html#torchvinecopulib.vinecop.DataVineCop.vcp_to_pkl">[docs]</a>
    <span class="k">def</span> <span class="nf">vcp_to_pkl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_path</span><span class="p">:</span> <span class="n">Path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;./vcp.pkl&quot;</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;save to a pickle file</span>

<span class="sd">        :param self: an instance of the DataVineCop dataclass</span>
<span class="sd">        :param f_path: file path to save the pickle file, defaults to Path(&#39;./vcp.pkl&#39;)</span>
<span class="sd">        :type f_path: Path, optional</span>
<span class="sd">        :return: file path where the pickle file is saved</span>
<span class="sd">        :rtype: Path</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">f_path</span><span class="p">)</span>
        <span class="n">f_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">f_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f_path</span></div>


<div class="viewcode-block" id="DataVineCop.l_pdf">
<a class="viewcode-back" href="../../../torchvinecopulib.vinecop.html#torchvinecopulib.vinecop.DataVineCop.l_pdf">[docs]</a>
    <span class="k">def</span> <span class="nf">l_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obs_mvcp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;log probability density function (PDF) of the multivariate copula</span>

<span class="sd">        :param self: an instance of the DataVineCop dataclass</span>
<span class="sd">        :param obs_mvcp: observation of the multivariate copula, of shape (num_obs, num_dim)</span>
<span class="sd">        :type obs_mvcp: torch.Tensor</span>
<span class="sd">        :return: log probability density function (PDF) of shape (num_obs, 1), given the observation</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># traverse all bicops in the tree, from top to bottom</span>
        <span class="n">num_dim</span> <span class="o">=</span> <span class="n">obs_mvcp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dct_obs</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)}</span>
        <span class="n">dct_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">()):</span> <span class="n">obs_mvcp</span><span class="p">[:,</span> <span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_dim</span><span class="p">)}</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">obs_mvcp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span>
            <span class="n">device</span><span class="o">=</span><span class="n">obs_mvcp</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">obs_mvcp</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">update_obs</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">):</span>
            <span class="c1"># * calc hfunc for pseudo obs when necessary</span>
            <span class="c1"># the lv of bcp</span>
            <span class="n">lv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_cond</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond_bcp</span><span class="p">),</span> <span class="n">bcp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_bcp</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># ! notice hfunc1 or hfunc2</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v_l</span> <span class="ow">and</span> <span class="n">s_cond</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">v_r</span><span class="p">}</span> <span class="o">|</span> <span class="n">s_cond_bcp</span><span class="p">):</span>
                    <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][(</span><span class="n">v</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">.</span><span class="n">hfunc2</span><span class="p">(</span>
                        <span class="n">obs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_cond_bcp</span><span class="p">],</span>
                                <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond_bcp</span><span class="p">],</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v_r</span> <span class="ow">and</span> <span class="n">s_cond</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">v_l</span><span class="p">}</span> <span class="o">|</span> <span class="n">s_cond_bcp</span><span class="p">):</span>
                    <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][(</span><span class="n">v</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">.</span><span class="n">hfunc1</span><span class="p">(</span>
                        <span class="n">obs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_cond_bcp</span><span class="p">],</span>
                                <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond_bcp</span><span class="p">],</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">for</span> <span class="n">lv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">),</span> <span class="n">bcp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_bcp</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># * update the pseudo observations</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">update_obs</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">s_cond</span><span class="o">=</span><span class="n">s_cond</span><span class="p">)</span>
                <span class="n">res</span> <span class="o">+=</span> <span class="n">bcp</span><span class="o">.</span><span class="n">l_pdf</span><span class="p">(</span>
                    <span class="n">obs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                        <span class="p">[</span>
                            <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">][(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">)],</span>
                            <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">][(</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">)],</span>
                        <span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># ! garbage collection</span>
                <span class="k">del</span> <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="DataVineCop.rosenblatt_transform">
<a class="viewcode-back" href="../../../torchvinecopulib.vinecop.html#torchvinecopulib.vinecop.DataVineCop.rosenblatt_transform">[docs]</a>
    <span class="k">def</span> <span class="nf">rosenblatt_transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obs_mvcp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">tpl_sim</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rosenblatt transformation, from the multivariate copula (with dependence) to the uniform multivariate copula (independent), using constructed vine copula</span>

<span class="sd">        :param obs_mvcp: observation of the multivariate copula, of shape (num_obs, num_dim)</span>
<span class="sd">        :type obs_mvcp: torch.Tensor</span>
<span class="sd">        :param tpl_sim: tuple of vertices (read from right to left) in a full simulation workflow, gives flexibility to experienced users, defaults to tuple()</span>
<span class="sd">        :type tpl_sim: tuple, optional</span>
<span class="sd">        :return: ideally independent uniform multivariate copula, of shape (num_obs, num_dim)</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tpl_sim</span><span class="p">:</span>
            <span class="n">tpl_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tpl_sim</span>
        <span class="n">tpl_sim_v_s_cond</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">tpl_sim</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]))</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tpl_sim</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">dct_obs</span> <span class="o">=</span> <span class="p">{</span><span class="n">_</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_dim</span><span class="p">)}</span>
        <span class="n">dct_obs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">()):</span> <span class="n">obs_mvcp</span><span class="p">[:,</span> <span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_dim</span><span class="p">)}</span>

        <span class="k">def</span> <span class="nf">update_obs</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">):</span>
            <span class="c1"># * calc hfunc for pseudo obs when necessary</span>
            <span class="c1"># the lv of bcp</span>
            <span class="n">lv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_cond</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond_bcp</span><span class="p">),</span> <span class="n">bcp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_bcp</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># ! notice hfunc1 or hfunc2</span>
                <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v_l</span> <span class="ow">and</span> <span class="n">s_cond</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">v_r</span><span class="p">}</span> <span class="o">|</span> <span class="n">s_cond_bcp</span><span class="p">):</span>
                    <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][(</span><span class="n">v</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">.</span><span class="n">hfunc2</span><span class="p">(</span>
                        <span class="n">obs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_cond_bcp</span><span class="p">],</span>
                                <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond_bcp</span><span class="p">],</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">v</span> <span class="o">==</span> <span class="n">v_r</span> <span class="ow">and</span> <span class="n">s_cond</span> <span class="o">==</span> <span class="nb">frozenset</span><span class="p">({</span><span class="n">v_l</span><span class="p">}</span> <span class="o">|</span> <span class="n">s_cond_bcp</span><span class="p">):</span>
                    <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][(</span><span class="n">v</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">)]</span> <span class="o">=</span> <span class="n">bcp</span><span class="o">.</span><span class="n">hfunc1</span><span class="p">(</span>
                        <span class="n">obs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                            <span class="p">[</span>
                                <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_cond_bcp</span><span class="p">],</span>
                                <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">][</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond_bcp</span><span class="p">],</span>
                            <span class="p">]</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">for</span> <span class="n">lv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_tree</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">),</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dct_bcp</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># * update the pseudo observations</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">s_cond</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">update_obs</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">s_cond</span><span class="o">=</span><span class="n">s_cond</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_cond</span> <span class="o">|</span> <span class="p">{</span><span class="n">v_r</span><span class="p">})</span> <span class="ow">in</span> <span class="n">tpl_sim_v_s_cond</span><span class="p">:</span>
                    <span class="n">update_obs</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_cond</span><span class="o">=</span><span class="n">s_cond</span> <span class="o">|</span> <span class="p">{</span><span class="n">v_r</span><span class="p">})</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span> <span class="o">|</span> <span class="p">{</span><span class="n">v_l</span><span class="p">})</span> <span class="ow">in</span> <span class="n">tpl_sim_v_s_cond</span><span class="p">:</span>
                    <span class="n">update_obs</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_cond</span><span class="o">=</span><span class="n">s_cond</span> <span class="o">|</span> <span class="p">{</span><span class="n">v_l</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">lv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># ! garbage collection</span>
                <span class="k">for</span> <span class="n">v_s_cond</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">v_s_cond</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tpl_sim_v_s_cond</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">dct_obs</span><span class="p">[</span><span class="n">lv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">v_s_cond</span><span class="p">]</span>
        <span class="n">dct_obs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">dct_lv</span> <span class="ow">in</span> <span class="n">dct_obs</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dct_lv</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">tpl_sim_v_s_cond</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dct_obs</span></div>


<div class="viewcode-block" id="DataVineCop.sim">
<a class="viewcode-back" href="../../../torchvinecopulib.vinecop.html#torchvinecopulib.vinecop.DataVineCop.sim">[docs]</a>
    <span class="k">def</span> <span class="nf">sim</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_sim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">dct_first_vs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">tpl_sim</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(),</span>
        <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">device</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cpu&quot;</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;full simulation/ quantile-regression/ conditional-simulation using the vine copula. Sequentially for each beginning vertex in the tpl_sim (from right to left, as from shallower lv to deeper lv in the DAG), walk upward by calling hinv until the top vertex (whose cond set is empty) is reached. (Recursively) call hfunc for the other upper vertex if necessary.</span>

<span class="sd">        :param num_sim: number of simulations; ignored when dct_first_vs is not empty</span>
<span class="sd">        :type num_sim: int</span>
<span class="sd">        :param dct_first_vs: dict of {(vertex,cond_set): torch.Tensor(size=(n,1))} in quantile regression/ conditional simulation, where vertices are taken as given already; defaults to {}</span>
<span class="sd">        :type dct_first_vs: dict, optional</span>
<span class="sd">        :param tpl_sim: tuple of vertices (read from right to left) in a full simulation workflow, gives flexibility to experienced users, defaults to tuple()</span>
<span class="sd">        :type tpl_sim: tuple, optional</span>
<span class="sd">        :param seed: random seed for torch.manual_seed(), defaults to 0</span>
<span class="sd">        :type seed: int, optional</span>
<span class="sd">        :param device: device for torch.rand(), defaults to &#39;cpu&#39;</span>
<span class="sd">        :type device: str, optional</span>
<span class="sd">        :param dtype: dtype for torch.rand(), defaults to torch.float64</span>
<span class="sd">        :type dtype: torch.dtype, optional</span>
<span class="sd">        :return: simulated observations of the vine copula, of shape (num_sim, num_dim)</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dct_obs</span> <span class="o">=</span> <span class="n">dct_first_vs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># * source vertices in each path; reference counting for whole DAG</span>
        <span class="n">dct_ref_count</span><span class="p">,</span> <span class="n">lst_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ref_count</span><span class="p">(</span>
            <span class="n">tpl_first_vs</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dct_first_vs</span><span class="p">),</span> <span class="n">tpl_sim</span><span class="o">=</span><span class="n">tpl_sim</span>
        <span class="p">)</span>

        <span class="k">def</span> <span class="nf">_update_ref_count</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># * countdown and release memory if necessary</span>
            <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">dct_obs</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">visit_hfunc</span><span class="p">(</span><span class="n">v_down</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">s_down</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            hfunc from (v_l,s_up) and (v_r,s_up) (both may not exist yet and recursively call visit_hfunc if necessary)</span>
<span class="sd">            to (v_down,s_down); then update dct_obs and dct_ref_count and do garbage collection</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># * locate the bicop on upper level that connects the 3 vertices</span>
            <span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_up</span><span class="p">,</span> <span class="n">bcp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc_bcp</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_down</span><span class="p">)</span>
            <span class="c1"># ! hfunc from even upper, to visit this vertex on upper level</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dct_obs</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">visit_hfunc</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_up</span><span class="p">)</span>
            <span class="n">dct_obs</span><span class="p">[</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">bcp</span><span class="o">.</span><span class="n">hfunc1</span> <span class="k">if</span> <span class="n">v_down</span> <span class="o">==</span> <span class="n">v_r</span> <span class="k">else</span> <span class="n">bcp</span><span class="o">.</span><span class="n">hfunc2</span><span class="p">)(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">dct_obs</span><span class="p">[</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_up</span><span class="p">],</span> <span class="n">dct_obs</span><span class="p">[</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_up</span><span class="p">]])</span>
            <span class="p">)</span>
            <span class="c1"># * garbage collection check</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span>
                <span class="p">(</span><span class="n">v_r</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span>
                <span class="p">(</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="n">_update_ref_count</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">visit_hinv</span><span class="p">(</span><span class="n">v_down</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">s_down</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            hinv from (v_down,s_down) (surely exist) and (v_up,s_up) (may not exist yet and recursively call visit_hfunc if necessary)</span>
<span class="sd">            to (v_down,s_up); then update dct_obs and dct_ref_count and do garbage collection</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># * locate the bicop on upper level that connects the 3 vertices</span>
            <span class="n">v_l</span><span class="p">,</span> <span class="n">v_r</span><span class="p">,</span> <span class="n">s_up</span><span class="p">,</span> <span class="n">bcp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_loc_bcp</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_down</span><span class="p">)</span>
            <span class="c1"># ! if v_down==v_r then go hinv1([(v_l,s_up), (v_r,s_down)])</span>
            <span class="n">is_down_right</span> <span class="o">=</span> <span class="n">v_down</span> <span class="o">==</span> <span class="n">v_r</span>
            <span class="p">(</span><span class="n">v_up</span><span class="p">,</span> <span class="n">hinv</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_l</span><span class="p">,</span> <span class="n">bcp</span><span class="o">.</span><span class="n">hinv1</span><span class="p">)</span> <span class="k">if</span> <span class="n">is_down_right</span> <span class="k">else</span> <span class="p">(</span><span class="n">v_r</span><span class="p">,</span> <span class="n">bcp</span><span class="o">.</span><span class="n">hinv2</span><span class="p">)</span>
            <span class="c1"># ! hfunc from even upper, to visit this vertex on upper level</span>
            <span class="k">if</span> <span class="n">dct_obs</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">v_up</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">visit_hfunc</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v_up</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_up</span><span class="p">)</span>
            <span class="n">dct_obs</span><span class="p">[</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_up</span><span class="p">]</span> <span class="o">=</span> <span class="n">hinv</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">dct_obs</span><span class="p">[</span><span class="n">v_up</span><span class="p">,</span> <span class="n">s_up</span><span class="p">],</span>
                        <span class="n">dct_obs</span><span class="p">[</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="p">],</span>
                    <span class="p">]</span>
                    <span class="k">if</span> <span class="n">is_down_right</span>
                    <span class="k">else</span> <span class="p">[</span>
                        <span class="n">dct_obs</span><span class="p">[</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="p">],</span>
                        <span class="n">dct_obs</span><span class="p">[</span><span class="n">v_up</span><span class="p">,</span> <span class="n">s_up</span><span class="p">],</span>
                    <span class="p">]</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># * garbage collection check</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">v_up</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span>
                <span class="p">(</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_down</span><span class="p">),</span>
                <span class="p">(</span><span class="n">v_down</span><span class="p">,</span> <span class="n">s_up</span><span class="p">),</span>
            <span class="p">):</span>
                <span class="n">_update_ref_count</span><span class="p">(</span><span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
            <span class="c1"># * return the next vertex</span>
            <span class="k">return</span> <span class="n">v_down</span><span class="p">,</span> <span class="n">s_up</span>

        <span class="n">torch</span><span class="o">.</span><span class="n">manual_seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="c1"># * init sim of U_mvcp (multivariate independent copula)</span>
        <span class="n">dim_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">dct_first_vs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dim_sim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># ! skip for quant-reg</span>
            <span class="n">U_mvcp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">num_sim</span><span class="p">,</span> <span class="n">dim_sim</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># * update dct_obs and dct_ref_count</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lst_source</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dct_obs</span><span class="p">:</span>
                <span class="n">dct_obs</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_mvcp</span><span class="p">[:,</span> <span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># ! let the top level obs (target vertices) escape garbage collection</span>
            <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">()]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># update ref count</span>
            <span class="n">dct_ref_count</span><span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">s</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">del</span> <span class="n">seed</span><span class="p">,</span> <span class="n">dct_first_vs</span><span class="p">,</span> <span class="n">idx</span>
        <span class="k">if</span> <span class="n">dim_sim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">U_mvcp</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">lst_source</span><span class="p">:</span>
            <span class="c1"># walk the path if cond set is not empty</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="c1"># call hinv and update vertex/cond-set iteratively to walk towards target vertex (top lv)</span>
                <span class="n">v_next</span><span class="p">,</span> <span class="n">s_next</span> <span class="o">=</span> <span class="n">visit_hinv</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_next</span><span class="p">):</span>
                    <span class="n">v_next</span><span class="p">,</span> <span class="n">s_next</span> <span class="o">=</span> <span class="n">visit_hinv</span><span class="p">(</span><span class="n">v_down</span><span class="o">=</span><span class="n">v_next</span><span class="p">,</span> <span class="n">s_down</span><span class="o">=</span><span class="n">s_next</span><span class="p">)</span>
        <span class="c1"># * sort pseudo obs by key</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">val</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dct_obs</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">))])</span></div>


<div class="viewcode-block" id="DataVineCop.cdf">
<a class="viewcode-back" href="../../../torchvinecopulib.vinecop.html#torchvinecopulib.vinecop.DataVineCop.cdf">[docs]</a>
    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obs_mvcp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">num_sim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;cumulative distribution function (CDF) of the multivariate copula given observations, by Monte Carlo.</span>

<span class="sd">        :param self: an instance of the DataVineCop dataclass</span>
<span class="sd">        :param obs_mvcp: observations of the multivariate copula, of shape (num_obs, num_dim)</span>
<span class="sd">        :type obs_mvcp: torch.Tensor</span>
<span class="sd">        :param num_sim: number of simulations, defaults to 10000</span>
<span class="sd">        :type num_sim: int, optional</span>
<span class="sd">        :param seed: random seed for torch.manual_seed(), defaults to 0</span>
<span class="sd">        :type seed: int, optional</span>
<span class="sd">        :return: cumulative distribution function (CDF) of shape (num_obs, 1), given observations</span>
<span class="sd">        :rtype: torch.Tensor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># * both obs_mvcp and obs_sim are of 2 dimensions</span>
        <span class="n">obs_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="p">(</span>
            <span class="n">num_sim</span><span class="o">=</span><span class="n">num_sim</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">obs_mvcp</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">obs_mvcp</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="c1"># * unsqueeze for broadcasting (num_sim, obs_mvcp.shape[0], num_dim) -&gt; (obs_mvcp.shape[0], 1)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">obs_sim</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">obs_mvcp</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">keepdim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">/</span> <span class="n">obs_sim</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
</div>

</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2024-, Tuoyuan Cheng, Kan Chen
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../../../_static/documentation_options.js?v=c7a7491c"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/scripts/furo.js?v=32e29ea5"></script>
    </body>
</html>